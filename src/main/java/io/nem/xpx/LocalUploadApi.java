/*
 * Proximax P2P Storage REST API
 * Proximax P2P Storage REST API
 *
 * OpenAPI spec version: v0.0.1
 * Contact: alvin.reyes@botmill.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.nem.xpx;

import io.ipfs.api.MerkleNode;
import io.ipfs.api.NamedStreamable;
import io.ipfs.multihash.Multihash;

import java.io.IOException;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.io.FileUtils;
import org.apache.tika.Tika;
import com.google.flatbuffers.FlatBufferBuilder;

import io.nem.api.ApiException;
import io.nem.xpx.intf.UploadApi;
import io.nem.xpx.model.DataHashByteArrayEntity;
import io.nem.xpx.model.PublishResult;
import io.nem.xpx.model.XpxSdkGlobalConstants;
import io.nem.xpx.model.buffers.ResourceHashMessage;
import io.nem.xpx.utils.JsonUtils;

import java.io.File;

public class LocalUploadApi implements UploadApi {

	@Override
	public String cleanupPinnedContentUsingPOST(String multihash) throws ApiException, IOException {
		return XpxSdkGlobalConstants.getProximaxConnection().pin.rm(Multihash.fromBase58(multihash)).toString();
	}

	@Override
	public Object uploadBase64StringBinaryUsingPOST(String data, String contentType, String name, String keywords,
			String metadata) throws ApiException, IOException, NoSuchAlgorithmException {

		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();

		dataHashByteArrayEntity.setFile(data.getBytes());
		if (name == null || (name != null && name.equals(""))) {
			dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");
		} else {
			dataHashByteArrayEntity.setName(name);
		}

		if (contentType == null || (contentType != null && contentType.equals(""))) {
			contentType = new Tika().detect(data);
		}

		dataHashByteArrayEntity.setContentType(contentType);
		dataHashByteArrayEntity.setKeywords(keywords);
		dataHashByteArrayEntity.setMetadata((metadata == null) ? null : JsonUtils.fromJson(metadata, Map.class));

		PublishResult spfsBlockResult = exposeAndPinBinary(dataHashByteArrayEntity.getName(),
				dataHashByteArrayEntity.getFile());
		String multiHashString = spfsBlockResult.getMerkleNode().get(0).hash.toBase58();

		FlatBufferBuilder builder = new FlatBufferBuilder(1024);

		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

		int digest = builder.createString(new String(
				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));

		int hash = builder.createString(multiHashString);
		int keywordsRes = builder.createString(
				(dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
		int metadataRes = builder.createString(JsonUtils
				.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
		int nameint = builder.createString(dataHashByteArrayEntity.getName());
		int type = builder.createString(dataHashByteArrayEntity.getContentType());

		ResourceHashMessage.startResourceHashMessage(builder);
		ResourceHashMessage.addDigest(builder, digest);
		ResourceHashMessage.addHash(builder, hash);
		ResourceHashMessage.addKeywords(builder, keywordsRes);
		ResourceHashMessage.addMetaData(builder, metadataRes);
		ResourceHashMessage.addName(builder, nameint);
		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
		ResourceHashMessage.addType(builder, type);
		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));

		return Base64.encodeBase64(builder.sizedByteArray());
	}

	@Override
	public Object uploadBytesBinaryUsingPOST(byte[] data, String contentType, String name, String keywords,
			String metadata) throws ApiException, IOException, NoSuchAlgorithmException {

		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();

		dataHashByteArrayEntity.setFile(data);
		if (name == null || (name != null && name.equals(""))) {
			dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");
		} else {
			dataHashByteArrayEntity.setName(name);
		}

		if (contentType == null || (contentType != null && contentType.equals(""))) {
			contentType = new Tika().detect(data);
		}

		dataHashByteArrayEntity.setContentType(contentType);
		dataHashByteArrayEntity.setKeywords(keywords);
		dataHashByteArrayEntity.setMetadata((metadata == null) ? null : JsonUtils.fromJson(metadata, Map.class));

		PublishResult spfsBlockResult = exposeAndPinBinary(dataHashByteArrayEntity.getName(),
				dataHashByteArrayEntity.getFile());
		String multiHashString = spfsBlockResult.getMerkleNode().get(0).hash.toBase58();

		FlatBufferBuilder builder = new FlatBufferBuilder(1024);

		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

		int digest = builder.createString(new String(
				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));

		int hash = builder.createString(multiHashString);
		int keywordsRes = builder.createString(
				(dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
		int metadataRes = builder.createString(JsonUtils
				.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
		int nameint = builder.createString(dataHashByteArrayEntity.getName());
		int type = builder.createString(dataHashByteArrayEntity.getContentType());

		ResourceHashMessage.startResourceHashMessage(builder);
		ResourceHashMessage.addDigest(builder, digest);
		ResourceHashMessage.addHash(builder, hash);
		ResourceHashMessage.addKeywords(builder, keywordsRes);
		ResourceHashMessage.addMetaData(builder, metadataRes);
		ResourceHashMessage.addName(builder, nameint);
		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
		ResourceHashMessage.addType(builder, type);
		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));

		return Base64.encodeBase64(builder.sizedByteArray());
	}

	@Override
	public Object uploadFileUsingPOST(File file, String name, String keywords, String metadata)
			throws ApiException, IOException, NoSuchAlgorithmException {
		// initialize the datahash byte array entity object.
		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();

		dataHashByteArrayEntity.setFile(FileUtils.readFileToByteArray(file));
		if (name == null || (name != null && name.equals(""))) {
			dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");
		} else {
			dataHashByteArrayEntity.setName(name);
		}

		String contentType = "text/plain";
		dataHashByteArrayEntity.setContentType(contentType);
		dataHashByteArrayEntity.setKeywords(keywords);
		dataHashByteArrayEntity.setMetadata((metadata == null) ? null : JsonUtils.fromJson(metadata, Map.class));

		// Expose/load the file.
		PublishResult spfsBlockResult = exposeAndPinBinary(dataHashByteArrayEntity.getName(),
				dataHashByteArrayEntity.getFile());

		String multiHashString = spfsBlockResult.getMerkleNode().get(0).hash.toBase58();

		// Serialize
		FlatBufferBuilder builder = new FlatBufferBuilder(1024);
		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

		int digest = builder.createString(new String(
				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));

		int hash = builder.createString(multiHashString);
		int keywordsRes = builder.createString(
				(dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
		int metadataRes = builder.createString(JsonUtils
				.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
		int nameint = builder.createString(dataHashByteArrayEntity.getName());
		int type = builder.createString(dataHashByteArrayEntity.getContentType());

		ResourceHashMessage.startResourceHashMessage(builder);
		ResourceHashMessage.addDigest(builder, digest);
		ResourceHashMessage.addHash(builder, hash);
		ResourceHashMessage.addKeywords(builder, keywordsRes);
		ResourceHashMessage.addMetaData(builder, metadataRes);
		ResourceHashMessage.addName(builder, nameint);
		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
		ResourceHashMessage.addType(builder, type);
		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));

		// return base64 encoded bytearray.
		return Base64.encodeBase64(builder.sizedByteArray());
	}

	@Override
	public Object uploadPlainTextUsingPOST(String text, String name, String encoding, String keywords, String metadata)
			throws ApiException, IOException, NoSuchAlgorithmException {

		// initialize the datahash byte array entity object.
		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();
		if (encoding == null || encoding.equals("")) {
			encoding = "UTF-8";
		}
		dataHashByteArrayEntity.setFile(text.getBytes(encoding));
		if (name == null || (name != null && name.equals(""))) {
			dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");
		} else {
			dataHashByteArrayEntity.setName(name);
		}

		String contentType = "text/plain";
		dataHashByteArrayEntity.setContentType(contentType);
		dataHashByteArrayEntity.setKeywords(keywords);
		dataHashByteArrayEntity.setMetadata((metadata == null) ? null : JsonUtils.fromJson(metadata, Map.class));

		// Expose/load the file.
		PublishResult spfsBlockResult = exposeAndPinBinary(dataHashByteArrayEntity.getName(),
				dataHashByteArrayEntity.getFile());

		String multiHashString = spfsBlockResult.getMerkleNode().get(0).hash.toBase58();

		// Serialize
		FlatBufferBuilder builder = new FlatBufferBuilder(1024);
		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

		int digest = builder.createString(new String(
				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));

		int hash = builder.createString(multiHashString);
		int keywordsRes = builder.createString(
				(dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
		int metadataRes = builder.createString(JsonUtils
				.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
		int nameint = builder.createString(dataHashByteArrayEntity.getName());
		int type = builder.createString(dataHashByteArrayEntity.getContentType());

		ResourceHashMessage.startResourceHashMessage(builder);
		ResourceHashMessage.addDigest(builder, digest);
		ResourceHashMessage.addHash(builder, hash);
		ResourceHashMessage.addKeywords(builder, keywordsRes);
		ResourceHashMessage.addMetaData(builder, metadataRes);
		ResourceHashMessage.addName(builder, nameint);
		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
		ResourceHashMessage.addType(builder, type);
		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));

		// return base64 encoded bytearray.
		return Base64.encodeBase64(builder.sizedByteArray());
	}

	public Object uploadPath(String path, String name, String keywords, String metadata) throws Exception {
		// initialize the datahash byte array entity object.
		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();

		dataHashByteArrayEntity.setFile(path.getBytes());
		if (name == null || (name != null && name.equals(""))) {
			dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");
		} else {
			dataHashByteArrayEntity.setName(name);
		}

		String contentType = "Directory";
		dataHashByteArrayEntity.setContentType(contentType);
		dataHashByteArrayEntity.setKeywords(keywords);
		dataHashByteArrayEntity.setMetadata((metadata == null) ? null : JsonUtils.fromJson(metadata, Map.class));

		// Expose/load the file.
		PublishResult spfsBlockResult = exposeAndPinPath(path);

		String multiHashString = "";

		Iterator<MerkleNode> merkleNodeIter = spfsBlockResult.getMerkleNode().iterator();

		// log it.
		spfsBlockResult.getMerkleNode().stream().forEach(n -> {
			System.out.println(n.hash + " " + n.name + " " + n.data);
		});

		while (merkleNodeIter.hasNext()) {
			MerkleNode merkleNode = (MerkleNode) merkleNodeIter.next();
			String namePath = "/" + merkleNode.name.get();
			if (namePath.equals(path)) {
				System.out.println("Assigned a sub merklenode");
				multiHashString = merkleNode.hash.toBase58();
				break;
			}
		}

		if (multiHashString == null || multiHashString.equals("")) {
			System.out.println("Assigned last merklenode");
			multiHashString = spfsBlockResult.getMerkleNode().get(spfsBlockResult.getMerkleNode().size() - 1).hash
					.toBase58();
		}

		// Serialize
		FlatBufferBuilder builder = new FlatBufferBuilder(1024);
		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

		int digest = builder.createString(new String(
				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));

		int hash = builder.createString(multiHashString);
		int keywordsRes = builder.createString(
				(dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
		int metadataRes = builder.createString(JsonUtils
				.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
		int nameint = builder.createString(dataHashByteArrayEntity.getName());
		int type = builder.createString(dataHashByteArrayEntity.getContentType());

		ResourceHashMessage.startResourceHashMessage(builder);
		ResourceHashMessage.addDigest(builder, digest);
		ResourceHashMessage.addHash(builder, hash);
		ResourceHashMessage.addKeywords(builder, keywordsRes);
		ResourceHashMessage.addMetaData(builder, metadataRes);
		ResourceHashMessage.addName(builder, nameint);
		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
		ResourceHashMessage.addType(builder, type);
		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));

		// return base64 encoded bytearray.
		return Base64.encodeBase64(builder.sizedByteArray());
	}

	/**
	 * Expose and pin binary.
	 *
	 * @param name
	 *            the name
	 * @param binary
	 *            the binary
	 * @return the publish result
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 * @throws ApiException
	 *             the api exception
	 */
	private PublishResult exposeAndPinBinary(String name, byte[] binary) throws IOException, ApiException {
		PublishResult result = new PublishResult();
		NamedStreamable.ByteArrayWrapper byteArrayWrapper = new NamedStreamable.ByteArrayWrapper(name, binary);
		List<MerkleNode> node = XpxSdkGlobalConstants.getProximaxConnection().add(byteArrayWrapper);
		List<Multihash> pinned = XpxSdkGlobalConstants.getProximaxConnection().pin.add(node.get(0).hash);
		result.setMerkleNode(node);
		result.setMultiHash(pinned);
		return result;
	}

	/**
	 * Expose and pin path.
	 *
	 * @param path
	 *            the path
	 * @return the publish result
	 * @throws Exception
	 *             the exception
	 */
	public PublishResult exposeAndPinPath(String path) throws Exception {
		PublishResult result = new PublishResult();
		try {
			List<NamedStreamable> streamables = new ArrayList<NamedStreamable>();
			NamedStreamable.FileWrapper fileWrapper = new NamedStreamable.FileWrapper(new File(path));
			streamables
					.add(new NamedStreamable.DirWrapper(new File(path).getAbsolutePath(), fileWrapper.getChildren()));
			// recursePathToBeAdded(streamables, path);
			List<MerkleNode> merkleNode = XpxSdkGlobalConstants.getProximaxConnection().add(streamables, true, false);
			result.setMerkleNode(merkleNode);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;

	}

	private void recursePathToBeAdded(List<NamedStreamable> streamables, String path) {
		File folder = new File(path);
		File[] listOfFiles = folder.listFiles();
		for (File file : listOfFiles) {
			if (file.isDirectory()) {
				NamedStreamable.FileWrapper fileWrapper = new NamedStreamable.FileWrapper(file);
				streamables.add(new NamedStreamable.DirWrapper(file.getAbsolutePath(), fileWrapper.getChildren()));
				recursePathToBeAdded(streamables, file.getAbsolutePath());
			} else {
				streamables.add(new NamedStreamable.FileWrapper(file));
			}
		}
	}

	/**
	 * Expose binary.
	 *
	 * @param name
	 *            the name
	 * @param binary
	 *            the binary
	 * @return the publish result
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 * @throws ApiException
	 *             the api exception
	 */
	private PublishResult exposeBinary(String name, byte[] binary) throws IOException, ApiException {
		PublishResult result = new PublishResult();
		NamedStreamable.ByteArrayWrapper byteArrayWrapper = new NamedStreamable.ByteArrayWrapper(name, binary);
		List<MerkleNode> node = XpxSdkGlobalConstants.getProximaxConnection().add(byteArrayWrapper);
		result.setMerkleNode(node);
		return result;
	}

	/**
	 * Gets the binary hash only.
	 *
	 * @param name
	 *            the name
	 * @param binary
	 *            the binary
	 * @return the binary hash only
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 * @throws ApiException
	 *             the api exception
	 */
	private PublishResult getBinaryHashOnly(String name, byte[] binary) throws IOException, ApiException {
		PublishResult result = null;

		// store it in ipfs
		result = new PublishResult();
		NamedStreamable.ByteArrayWrapper byteArrayWrapper = new NamedStreamable.ByteArrayWrapper(name, binary);
		List<MerkleNode> node = XpxSdkGlobalConstants.getProximaxConnection().add(byteArrayWrapper, false, true);
		result.setMerkleNode(node);

		return result;
	}

	/**
	 * Grab dirs.
	 *
	 * @param path
	 *            the path
	 * @param node
	 *            the node
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 * @throws ApiException
	 *             the api exception
	 */
	private void grabDirs(String path, List<MerkleNode> node) throws IOException, ApiException {
		File[] directories = new File(path).listFiles(File::isDirectory);
		for (File f : directories) {
			NamedStreamable.FileWrapper fileWrapper = new NamedStreamable.FileWrapper(f);
			NamedStreamable.DirWrapper dirWrapper = new NamedStreamable.DirWrapper(f.getName().toString(),
					fileWrapper.getChildren());
			node.addAll(XpxSdkGlobalConstants.getProximaxConnection().add(dirWrapper, true, false));
			grabDirs(f.getAbsolutePath(), node);
		}
	}

}
