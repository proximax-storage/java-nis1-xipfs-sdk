/*
 * Proximax P2P Storage REST API
 * Proximax P2P Storage REST API
 *
 * OpenAPI spec version: v0.0.1
 * Contact: proximax.storage@proximax.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.nem.xpx;

import io.nem.api.ApiCallback;
import io.nem.api.ApiClient;
import io.nem.api.ApiException;
import io.nem.api.ApiResponse;
import io.nem.Configuration;
import io.nem.Pair;
import io.nem.ProgressRequestBody;
import io.nem.ProgressResponseBody;
import com.google.gson.reflect.TypeToken;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import io.nem.xpx.model.ResourceHashMessageJsonEntity;
import io.nem.xpx.model.buffers.ResourceHashMessage;
import io.nem.xpx.utils.JsonUtils;
import java.lang.reflect.Type;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.regex.Pattern;

import org.apache.commons.codec.binary.Base64;
import org.nem.core.crypto.KeyPair;
import org.nem.core.crypto.PrivateKey;
import org.nem.core.crypto.PublicKey;
import org.nem.core.messages.SecureMessage;
import org.nem.core.model.Account;
import org.nem.core.model.Address;
import org.nem.core.model.TransferTransaction;
import org.nem.core.model.ncc.TransactionMetaDataPair;

public class LocalSearchApi implements SearchApi {

	@Override
	public List<ResourceHashMessageJsonEntity> searchTransactionWithKeywordUsingGET(String xPubkey, String keywords)
			throws ApiException, InterruptedException, ExecutionException {

		PublicKey pbKey = PublicKey.fromHexString(xPubkey);
		Address address = Address.fromPublicKey(pbKey);
		String publicKeyAddress = address.toString();

		List<TransactionMetaDataPair> listOfTransactionMetadataPair = TransactionApi
				.getAllTransactionsWithPageSize(publicKeyAddress, "100");

		List<ResourceHashMessageJsonEntity> encryptedMessage = new ArrayList<ResourceHashMessageJsonEntity>();
		// loop thru and search for any keyword.

		for (TransactionMetaDataPair tmp : listOfTransactionMetadataPair) {
			// we only process plain. We don't have access to the secure
			// messages at this point.
			if (tmp.getEntity() instanceof TransferTransaction) {

				TransferTransaction transferTransaction = (TransferTransaction) tmp.getEntity();
				try {
					if (transferTransaction.getMessage().getType() == 1) {

						boolean found = false;
						ResourceHashMessage resourceMessage = ResourceHashMessage
								.getRootAsResourceHashMessage(ByteBuffer.wrap(
										Base64.decodeBase64(transferTransaction.getMessage().getDecodedPayload())));

						String[] commaSeparatedkeywordsSplit = keywords.split(",");
						for (String keyword : commaSeparatedkeywordsSplit) {
							if (resourceMessage.keywords().contains(keyword)) {
								found = true;
								break;
							}
						}

						if (found) {
							encryptedMessage.add(toEntity(resourceMessage));
						}

					}
				} catch (Exception e) {
					continue;
				}
			}
		}
		return encryptedMessage;
	}

	@Override
	public List<ResourceHashMessageJsonEntity> searchTransactionWithKeywordUsingGET(String xPvKey, String xPubkey,
			String keywords) throws ApiException, InterruptedException, ExecutionException {
		
		PrivateKey pvKey = PrivateKey.fromHexString(xPvKey);
		KeyPair keyPair = new KeyPair(pvKey);
		String privateKeyAddress = Address.fromPublicKey(keyPair.getPublicKey()).toString();

		List<TransactionMetaDataPair> listOfTransactionMetadataPair = TransactionApi
				.getAllTransactionsWithPageSize(privateKeyAddress, "100");

		List<ResourceHashMessageJsonEntity> encryptedMessage = new ArrayList<ResourceHashMessageJsonEntity>();
		// loop thru and search for any keyword.

		for (TransactionMetaDataPair tmp : listOfTransactionMetadataPair) {
			// we only process plain. We don't have access to the secure
			// messages at this point.
			if (tmp.getEntity() instanceof TransferTransaction) {
				TransferTransaction transferTransaction = (TransferTransaction) tmp.getEntity();

				boolean found = false;
				try {
		
					if (transferTransaction.getMessage().getType() == 1) {

						ResourceHashMessage resourceMessage = ResourceHashMessage
								.getRootAsResourceHashMessage(ByteBuffer.wrap(
										Base64.decodeBase64(transferTransaction.getMessage().getDecodedPayload())));

						String[] commaSeparatedkeywordsSplit = keywords.split(",");
						for (String keyword : commaSeparatedkeywordsSplit) {
							if (resourceMessage.keywords().contains(keyword)) {
								found = true;
								break;
							}
						}

						if (found) {
							encryptedMessage.add(toEntity(resourceMessage));
						}

					} else if (transferTransaction.getMessage().getType() == 2) {

						SecureMessage secureMessage = null;
						if (transferTransaction.getSigner().getAddress().getEncoded()
								.equals(privateKeyAddress)) {
							secureMessage = SecureMessage.fromEncodedPayload(
									new Account(new KeyPair(PrivateKey.fromHexString(xPvKey))),
									new Account(new KeyPair(PublicKey.fromHexString(xPubkey))),
									transferTransaction.getMessage().getEncodedPayload());
							
						} else if (transferTransaction.getRecipient().getAddress().getEncoded()
								.equals(privateKeyAddress)) {
							secureMessage = SecureMessage.fromEncodedPayload(
									new Account(new KeyPair(PublicKey.fromHexString(xPubkey))),
									new Account(new KeyPair(PrivateKey.fromHexString(xPvKey))),
									transferTransaction.getMessage().getEncodedPayload());
						}

						ResourceHashMessage resourceMessage = ResourceHashMessage
								.getRootAsResourceHashMessage(ByteBuffer.wrap(
										Base64.decodeBase64(secureMessage.getDecodedPayload())));

						String[] commaSeparatedkeywordsSplit = keywords.split(",");
						for (String keyword : commaSeparatedkeywordsSplit) {
							if (resourceMessage.keywords().contains(keyword)) {
								found = true;
								break;
							}
						}

						if (found) {
							encryptedMessage.add(toEntity(resourceMessage));
						}

					}

				} catch (Exception e) {
					e.printStackTrace();
					continue;
				}
			}
		}
		return encryptedMessage;
	}

	@Override
	public List<ResourceHashMessageJsonEntity> searchTransactionWithMetadataUsingGET(String xPubkey, String text)
			throws ApiException {
		// TODO Auto-generated method stub
		return null;
	}

	private ResourceHashMessageJsonEntity toEntity(ResourceHashMessage resourceMessage) {

		ResourceHashMessageJsonEntity resourceHashMessageJsonEntity = new ResourceHashMessageJsonEntity();
		resourceHashMessageJsonEntity.setDigest(resourceMessage.digest());
		resourceHashMessageJsonEntity.setHash(resourceMessage.hash());
		resourceHashMessageJsonEntity.setKeywords(resourceMessage.keywords());
		resourceHashMessageJsonEntity.setMetaData(resourceMessage.metaData());
		resourceHashMessageJsonEntity.setName(resourceMessage.name());
		resourceHashMessageJsonEntity.setTimestamp(resourceMessage.timestamp());
		resourceHashMessageJsonEntity.setType(resourceMessage.type());
		return resourceHashMessageJsonEntity;
	}

}
