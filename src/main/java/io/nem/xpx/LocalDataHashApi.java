/*
 * Proximax P2P Storage REST API
 * Proximax P2P Storage REST API
 *
 * OpenAPI spec version: v0.0.1
 * Contact: alvin.reyes@botmill.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.nem.xpx;

import io.ipfs.api.MerkleNode;
import io.ipfs.api.NamedStreamable;

import java.io.IOException;
import java.nio.file.Paths;

import io.nem.api.ApiException;
import io.nem.xpx.intf.DataHashApi;
import io.nem.xpx.model.DataHashByteArrayEntity;
import io.nem.xpx.model.PublishResult;
import io.nem.xpx.model.XpxSdkGlobalConstants;
import java.security.NoSuchAlgorithmException;
import java.util.List;



/**
 * The Class LocalDataHashApi.
 */
public class LocalDataHashApi implements DataHashApi {

	/* (non-Javadoc)
	 * @see io.nem.xpx.DataHashApiInterface#generateHashAndExposeDataToNetworkUsingPOST(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
	 */
	@SuppressWarnings("unchecked")
	@Override
	public String generateHashForDataOnlyUsingPOST(byte[] data) throws ApiException, IOException, NoSuchAlgorithmException {

		
		
		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();
		dataHashByteArrayEntity.setFile(data);
		dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");

		
		PublishResult spfsBlockResult = getBinaryHashOnly(dataHashByteArrayEntity.getName(),
				dataHashByteArrayEntity.getFile());

		String multiHashString = spfsBlockResult.getMerkleNode().get(0).hash.toBase58();
		return multiHashString;
//		
//		//	flat bufferize the binaryEncryptedMessage.
//		FlatBufferBuilder builder  = new FlatBufferBuilder(1024);
//		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
//		int digest =  builder.createString(new String(
//				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));
//		
//		int hash = builder.createString(multiHashString);
//		int keywords = builder.createString((dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
//		int metadata = builder.createString(JsonUtils.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
//		int name =  builder.createString(dataHashByteArrayEntity.getName());
//		int type = builder.createString(dataHashByteArrayEntity.getContentType());
//		
//		ResourceHashMessage.startResourceHashMessage(builder);
//		ResourceHashMessage.addDigest(builder,digest);
//		ResourceHashMessage.addHash(builder, hash);
//		ResourceHashMessage.addKeywords(builder, keywords);
//		ResourceHashMessage.addMetaData(builder,  metadata);
//		ResourceHashMessage.addName(builder, name);
//		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
//		ResourceHashMessage.addType(builder, type);
//		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));
//		return ResourceHashMessage.getRootAsResourceHashMessage(ByteBuffer.wrap(Base64.decodeBase64(builder.sizedByteArray())));
		

	}

	
	
	/**
	 * Expose and pin path.
	 *
	 * @param path the path
	 * @return the publish result
	 * @throws Exception the exception
	 */
	public PublishResult exposeAndPinPath(String path) throws Exception {

		PublishResult result = new PublishResult();		
		System.out.println(Paths.get(path).getFileName().toString());
		NamedStreamable.FileWrapper fileWrapper = new NamedStreamable.FileWrapper(Paths.get(path).toFile());
		NamedStreamable.DirWrapper dirWrapper = new NamedStreamable.DirWrapper(Paths.get(path).getFileName().toString(),fileWrapper.getChildren());
		List<MerkleNode> node1 = XpxSdkGlobalConstants.getProximaxConnection().add(fileWrapper,true,false);
		List<MerkleNode> node2 = XpxSdkGlobalConstants.getProximaxConnection().add(dirWrapper,false,false);
		
		node1.forEach(p -> {
			//System.out.println(p.toJSON());
		});
		
		node2.forEach(p -> {
			
			System.out.println(p.toJSONString());
		});
		
		//grabDirs(path,node);
		result.setMerkleNode(node1);

		
		return result;

	}
	

	/**
	 * Gets the binary hash only.
	 *
	 * @param name the name
	 * @param binary the binary
	 * @return the binary hash only
	 * @throws IOException Signals that an I/O exception has occurred.
	 * @throws ApiException the api exception
	 */
	private PublishResult getBinaryHashOnly(String name, byte[] binary) throws IOException, ApiException {
		PublishResult result = null;

		// store it in ipfs
		result = new PublishResult();
		NamedStreamable.ByteArrayWrapper byteArrayWrapper = new NamedStreamable.ByteArrayWrapper(name, binary);
		List<MerkleNode> node = XpxSdkGlobalConstants.getProximaxConnection().add(byteArrayWrapper,false,true);
		result.setMerkleNode(node);

		return result;
	}
	
	
}
